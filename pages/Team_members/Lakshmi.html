<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="template.css">
</head>
<body>
    <nav class="navbar">
        <ul class="nav-list">
            <li><a href="/Portfolio-DAA/index.html">Home</a></li>
          <li><a href="/Portfolio-DAA/pages/project-intro/project-intro.html">Project Introduction</a></li>
          <li><a href="/Portfolio-DAA/pages/learning-refl/learning-reflection.html">Learning Reflections</a></li>
        </ul>
      </nav>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
   
    </style>
</head>
<body>
    <h2>1. Problems in Nature</h2>
    <h3>Iteration</h3>
    <ul>
        <li>Spider web</li>
        <li>Social media feeds</li>
        <li>Bee hive</li>
    </ul>
    <h3>Recursion</h3>
    <ul>
        <li>Petal arrangement in flowers</li>
        <li>Sea shell arrangements</li>
        <li>Food chain</li>
    </ul>
    <h3>Backtracking</h3>
    <ul>
        <li>Beaver dam construction</li>
        <li>Crossword puzzles</li>
    </ul>

    <h2>2. Time and Space Efficiency</h2>
    <p><strong>Time efficiency:</strong> Amount of time an algorithm takes to execute as a function of the input size.</p>
    <p><strong>Space efficiency:</strong> Amount of memory or storage an algorithm requires during execution.</p>
    <p><strong>Importance:</strong> Ensures algorithms run quickly and use minimal resources. Time efficiency improves performance and user experience, while space efficiency is crucial in memory-constrained environments.</p>

    <h3>Classes of Problems</h3>
    <ul>
        <li>Constant: O(1)</li>
        <li>Logarithmic: O(log(n))</li>
        <li>Linear: O(n)</li>
        <li>Quadratic: O(n²)</li>
        <li>Cubic: O(n³)</li>
        <li>Exponential: O(2ⁿ)</li>
        <li>Factorial: O(n!)</li>
    </ul>

    <h3>Orders of Growth</h3>
    <ul>
        <li><strong>Best case:</strong> Minimum time required under optimal conditions.</li>
        <li><strong>Average case:</strong> Expected time over all possible inputs.</li>
        <li><strong>Worst case:</strong> Maximum time required.</li>
    </ul>

    <h2>3. Sorting Algorithms</h2>
    <ul>
        <li><strong>Bubble Sort:</strong> Repeatedly swaps adjacent elements. Inefficient with O(n²) time complexity.</li>
        <li><strong>Selection Sort:</strong> Selects the smallest (or largest) element and places it in its correct position. O(n²) time complexity.</li>
        <li><strong>Merge Sort:</strong> Divides, recursively sorts, and merges. O(n log n) time complexity.</li>
        <li><strong>Quick Sort:</strong> Divides the array around a pivot and recursively sorts. Average time complexity O(n log n).</li>
        <li><strong>Insertion Sort:</strong> Builds the sorted array one element at a time. Efficient for small or nearly sorted data. O(n²) time complexity.</li>
        <li><strong>Heap Sort:</strong> Uses a binary heap to repeatedly extract the largest element. O(n log n) time complexity.</li>
    </ul>

    <h3>Graph Algorithms</h3>
    <ul>
        <li><strong>Boyer-Moore Algorithm:</strong> Efficient string-searching algorithm.</li>
        <li><strong>Kruskal’s Algorithm:</strong> Finds minimum spanning trees using a union-find structure.</li>
        <li><strong>Dijkstra’s Algorithm:</strong> Finds the shortest paths using a priority queue.</li>
        <li><strong>Floyd-Warshall Algorithm:</strong> Computes shortest paths between all pairs. O(n³) time complexity.</li>
        <li><strong>Prim’s Algorithm:</strong> Builds a minimum spanning tree by growing the tree.</li>
    </ul>

    <h2>4. Hierarchical Data Representation</h2>
    <ul>
        <li><strong>Tree:</strong> General structure for hierarchies.</li>
        <li><strong>Binary Search Tree (BST):</strong> Maintains sorted order. O(log n) average-case operations.</li>
        <li><strong>AVL Tree:</strong> Guarantees O(log n) operations through balancing.</li>
        <li><strong>2-3 Tree:</strong> Balanced multiway search tree with predictable O(log n) performance.</li>
        <li><strong>Red-Black Tree:</strong> Self-balancing BST with efficient O(log n) operations.</li>
        <li><strong>Heap:</strong> Efficient for priority management with O(1) min/max access.</li>
        <li><strong>Trie:</strong> Fast prefix-based searches. O(n) complexity.</li>
    </ul>

    <h2>5. Array Query Algorithms</h2>
    <p><strong>Need:</strong> Quickly answer questions about array data.</p>
    <p><strong>Implications:</strong> Handle big datasets efficiently, crucial for gaming, data analysis, and real-time systems.</p>
    <p><strong>Principles:</strong> Store extra data and split arrays for faster processing.</p>
    <p><strong>Applications:</strong> Range queries for sum, max, min; fast updates.</p>

    <h2>6. Difference Between Tree and Graph</h2>
    <ul>
        <li>Trees are hierarchical with no cycles.</li>
        <li>Graphs can have cycles and multiple connections.</li>
        <li>Trees have exactly one path between two nodes; graphs can have multiple paths.</li>
        <li>A tree with n nodes has n-1 edges; graphs can have any number of edges.</li>
    </ul>

    <h3>Traversals</h3>
    <ul>
        <li><strong>Tree Traversals:</strong> Inorder, Preorder, Postorder</li>
        <li><strong>Graph Traversals:</strong> Depth-First Search (DFS), Breadth-First Search (BFS)</li>
    </ul>

    <h3>Applications</h3>
    <ul>
        <li><strong>Trees:</strong> BST for efficient searching, Heap for priority queues, Trie for fast prefix searches.</li>
        <li><strong>Graphs:</strong> Shortest path algorithms for navigation, network flow, cycle detection.</li>
    </ul>

    <h2>7. Spanning Trees and Shortest Paths</h2>
    <h3>Spanning Tree</h3>
    <p>Connect all vertices with minimum edges and no cycles.</p>
    <p><strong>Importance:</strong> Used in network design and distributed systems.</p>
    <p><strong>Algorithms:</strong> Kruskal’s, Prim’s</p>

    <h3>Shortest Paths</h3>
    <p>Find the minimum weight path between vertices.</p>
    <p><strong>Importance:</strong> Used in navigation, optimization, AI pathfinding.</p>
    <p><strong>Algorithm:</strong> Dijkstra’s</p>
</body>
</html>
